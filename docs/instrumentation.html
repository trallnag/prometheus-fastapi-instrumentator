<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>prometheus_fastapi_instrumentator.instrumentation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>prometheus_fastapi_instrumentator.instrumentation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright Â© 2020 Tim Schwenke &lt;tim.and.trallnag+code@gmail.com&gt;
# Licensed under Apache License 2.0 &lt;http://www.apache.org/licenses/LICENSE-2.0&gt;

import gzip
import os
import re
import warnings
from timeit import default_timer
from typing import Callable, List, Optional, Pattern, Tuple

from fastapi import FastAPI
from prometheus_client import Gauge
from starlette.requests import Request
from starlette.responses import Response
from starlette.routing import Match

from prometheus_fastapi_instrumentator import metrics


class PrometheusFastApiInstrumentator:
    def __init__(
        self,
        should_group_status_codes: bool = True,
        should_ignore_untemplated: bool = False,
        should_group_untemplated: bool = True,
        should_round_latency_decimals: bool = False,
        should_respect_env_var: bool = False,
        should_instrument_requests_inprogress: bool = False,
        excluded_handlers: List[str] = [],
        round_latency_decimals: int = 4,
        env_var_name: str = &#34;ENABLE_METRICS&#34;,
        inprogress_name: str = &#34;http_requests_inprogress&#34;,
        inprogress_labels: bool = False,
    ):
        &#34;&#34;&#34;Create a Prometheus FastAPI Instrumentator.

        Args:
            should_group_status_codes (bool): Should status codes be grouped into
                `2xx`, `3xx` and so on? Defaults to `True`.

            should_ignore_untemplated (bool): Should requests without a matching
                template be ignored? Defaults to `False`. This means that by
                default a request like `curl -X GET localhost:80/doesnotexist`
                will be ignored.

            should_group_untemplated (bool): Should requests without a matching
                template be grouped to handler `none`? Defaults to `True`.

            should_round_latency_decimals: Should recorded latencies be
                rounded to a certain number of decimals?

            should_respect_env_var (bool): Should the instrumentator only work - for
                example the methods `instrument()` and `expose()` - if a
                certain environment variable is set to `true`? Usecase: A base
                FastAPI app that is used by multiple distinct apps. The apps
                only have to set the variable to be instrumented. Defaults to
                `False`.

            should_instrument_requests_inprogress (bool): Enables a gauge that shows
                the inprogress requests. See also the related args starting
                with `inprogress`. Defaults to `False`.

            excluded_handlers (List[str]): List of strings that will be compiled
                to regex patterns. All matches will be skipped and not
                instrumented. Defaults to `[]`.

            round_latency_decimals (int): Number of decimals latencies should be
                rounded to. Ignored unless `should_round_latency_decimals` is
                `True`. Defaults to `4`.

            env_var_name (str): Any valid os environment variable name that will
                be checked for existence before instrumentation. Ignored unless
                `should_respect_env_var` is `True`. Defaults to `&#34;ENABLE_METRICS&#34;`.

            inprogress_name (str): Name of the gauge. Defaults to
                `http_requests_inprogress`. Ignored unless
                `should_instrument_requests_inprogress` is `True`.

            inprogress_labels (bool): Should labels `method` and `handler` be
                part of the inprogress label? Ignored unless
                `should_instrument_requests_inprogress` is `True`. Defaults to `False`.
        &#34;&#34;&#34;

        self.should_group_status_codes = should_group_status_codes
        self.should_ignore_untemplated = should_ignore_untemplated
        self.should_group_untemplated = should_group_untemplated
        self.should_round_latency_decimals = should_round_latency_decimals
        self.should_respect_env_var = should_respect_env_var
        self.should_instrument_requests_inprogress = should_instrument_requests_inprogress

        self.round_latency_decimals = round_latency_decimals
        self.env_var_name = env_var_name
        self.inprogress_name = inprogress_name
        self.inprogress_labels = inprogress_labels

        self.excluded_handlers: List[Pattern[str]]
        if excluded_handlers:
            self.excluded_handlers = [re.compile(path) for path in excluded_handlers]
        else:
            self.excluded_handlers = []

        self.instrumentations: List[Callable[[metrics.Info], None]] = []

    # ==========================================================================

    def instrument(self, app: FastAPI):
        &#34;&#34;&#34;Performs the instrumentation by adding middleware.

        The middleware iterates through all `instrumentations` and executes them.

        Args:
            app (FastAPI): FastAPI app instance.

        Raises:
            e: Only raised if FastAPI itself throws an exception.

        Returns:
            self: Instrumentator. Builder Pattern.
        &#34;&#34;&#34;

        if (
            self.should_respect_env_var
            and os.environ.get(self.env_var_name, &#34;false&#34;) != &#34;true&#34;
        ):
            return self

        if len(self.instrumentations) == 0:
            self.instrumentations.append(metrics.default())

        if self.should_instrument_requests_inprogress:
            labels = (
                (
                    &#34;method&#34;,
                    &#34;handler&#34;,
                )
                if self.inprogress_labels
                else ()
            )
            self.inprogress = Gauge(
                name=self.inprogress_name,
                documentation=&#34;Number of HTTP requests in progress.&#34;,
                labelnames=labels,
                multiprocess_mode=&#34;livesum&#34;,
            )

        # ----------------------------------------------------------------------

        @app.middleware(&#34;http&#34;)
        async def dispatch_middleware(request: Request, call_next) -&gt; Response:
            start_time = default_timer()

            handler, is_templated = self._get_handler(request)
            is_excluded = self._is_handler_excluded(handler, is_templated)
            handler = (
                &#34;none&#34; if not is_templated and self.should_group_untemplated else handler
            )

            if not is_excluded and self.should_instrument_requests_inprogress:
                inprogress: Gauge
                if self.inprogress_labels:
                    inprogress = self.inprogress.labels(request.method, handler)
                else:
                    inprogress = self.inprogress
                inprogress.inc()

            response = None
            status = &#34;500&#34;

            try:
                response = await call_next(request)
                status = str(response.status_code)
            except Exception as e:
                raise e from None
            finally:
                if not is_excluded:
                    duration = max(default_timer() - start_time, 0)

                    if self.should_instrument_requests_inprogress:
                        inprogress.dec()  # type: ignore

                    if self.should_round_latency_decimals:
                        duration = round(duration, self.round_latency_decimals)

                    if self.should_group_status_codes:
                        status = status[0] + &#34;xx&#34;

                    info = metrics.Info(
                        request=request,
                        response=response,
                        method=request.method,
                        modified_handler=handler,
                        modified_status=status,
                        modified_duration=duration,
                    )

                    for instrumentation in self.instrumentations:
                        instrumentation(info)

            return response

        # ----------------------------------------------------------------------

        return self

    # ==========================================================================

    def expose(
        self,
        app: FastAPI,
        should_gzip: bool = False,
        endpoint: str = &#34;/metrics&#34;,
        include_in_schema: bool = True,
        tags: Optional[List[str]] = None,
        **kwargs,
    ):
        &#34;&#34;&#34;Exposes endpoint for metrics.

        Args:
            app: FastAPI app instance. Endpoint will be added to this app.

            should_gzip: Should the endpoint return compressed data? It will
                also check for `gzip` in the `Accept-Encoding` header.
                Compression consumes more CPU cycles. In most cases it&#39;s best
                to just leave this option off since network bandwith is usually
                cheaper than CPU cycles. Defaults to `False`.

            endpoint: Endpoint on which metrics should be exposed.

            include_in_schema: Should the endpoint show up in the documentation?

            tags (List[str], optional): If you manage your routes with tags.
                Defaults to None.

            kwargs: Will be passed to FastAPI route annotation.

        Raises:
            ValueError: If `PROMETHEUS_MULTIPROC_DIR` env var is found but
                doesn&#39;t point to a valid directory.

        Returns:
            self: Instrumentator. Builder Pattern.
        &#34;&#34;&#34;

        if (
            self.should_respect_env_var
            and os.environ.get(self.env_var_name, &#34;false&#34;) != &#34;true&#34;
        ):
            return self

        from prometheus_client import (
            CONTENT_TYPE_LATEST,
            REGISTRY,
            CollectorRegistry,
            generate_latest,
            multiprocess,
        )

        if (
            &#34;prometheus_multiproc_dir&#34; in os.environ
            and &#34;PROMETHEUS_MULTIPROC_DIR&#34; not in os.environ
        ):
            os.environ[&#34;PROMETHEUS_MULTIPROC_DIR&#34;] = os.environ[
                &#34;prometheus_multiproc_dir&#34;
            ]
            warnings.warn(
                &#34;prometheus_multiproc_dir variable has been deprecated in favor of the \
upper case naming PROMETHEUS_MULTIPROC_DIR&#34;,
                DeprecationWarning,
            )
        if &#34;PROMETHEUS_MULTIPROC_DIR&#34; in os.environ:
            pmd = os.environ[&#34;PROMETHEUS_MULTIPROC_DIR&#34;]
            if os.path.isdir(pmd):
                registry = CollectorRegistry()
                multiprocess.MultiProcessCollector(registry)
            else:
                raise ValueError(
                    f&#34;Env var PROMETHEUS_MULTIPROC_DIR=&#39;{pmd}&#39; not a directory.&#34;
                )
        else:
            registry = REGISTRY

        @app.get(endpoint, include_in_schema=include_in_schema, tags=tags, **kwargs)
        def metrics(request: Request):
            &#34;&#34;&#34;Endpoint that serves Prometheus metrics.&#34;&#34;&#34;

            if should_gzip and &#34;gzip&#34; in request.headers.get(&#34;Accept-Encoding&#34;, &#34;&#34;):
                resp = Response(content=gzip.compress(generate_latest(registry)))
                resp.headers[&#34;Content-Type&#34;] = CONTENT_TYPE_LATEST
                resp.headers[&#34;Content-Encoding&#34;] = &#34;gzip&#34;
                return resp
            else:
                resp = Response(content=generate_latest(registry))
                resp.headers[&#34;Content-Type&#34;] = CONTENT_TYPE_LATEST
                return resp

        return self

    # ==========================================================================

    def add(self, instrumentation_function: Callable[[metrics.Info], None]):
        &#34;&#34;&#34;Adds function to list of instrumentations.

        Args:
            instrumentation_function (Callable[[metrics.Info], None]): Function
                that will be executed during every request handler call (if
                not excluded). See above for detailed information on the
                interface of the function.

        Returns:
            self: Instrumentator. Builder Pattern.
        &#34;&#34;&#34;

        self.instrumentations.append(instrumentation_function)

        return self

    # ==========================================================================

    def _get_handler(self, request: Request) -&gt; Tuple[str, bool]:
        &#34;&#34;&#34;Extracts either template or (if no template) path.

        Args:
            request (Request): Python Requests request object.

        Returns:
            Tuple[str, bool]: Tuple with two elements. First element is either
                template or if no template the path. Second element tells you
                if the path is templated or not.
        &#34;&#34;&#34;

        for route in request.app.routes:
            match, _ = route.matches(request.scope)
            if match == Match.FULL:
                return route.path, True

        return request.url.path, False

    # ==========================================================================

    def _is_handler_excluded(self, handler: str, is_templated: bool) -&gt; bool:
        &#34;&#34;&#34;Determines if the handler should be ignored.

        Args:
            handler (str): Handler that handles the request.
            is_templated (bool): Shows if the request is templated.

        Returns:
            bool: `True` if excluded, `False` if not.
        &#34;&#34;&#34;

        if is_templated is False and self.should_ignore_untemplated:
            return True

        if any(pattern.search(handler) for pattern in self.excluded_handlers):
            return True

        return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="prometheus_fastapi_instrumentator.instrumentation.PrometheusFastApiInstrumentator"><code class="flex name class">
<span>class <span class="ident">PrometheusFastApiInstrumentator</span></span>
<span>(</span><span>should_group_status_codes:Â boolÂ =Â True, should_ignore_untemplated:Â boolÂ =Â False, should_group_untemplated:Â boolÂ =Â True, should_round_latency_decimals:Â boolÂ =Â False, should_respect_env_var:Â boolÂ =Â False, should_instrument_requests_inprogress:Â boolÂ =Â False, excluded_handlers:Â List[str]Â =Â [], round_latency_decimals:Â intÂ =Â 4, env_var_name:Â strÂ =Â 'ENABLE_METRICS', inprogress_name:Â strÂ =Â 'http_requests_inprogress', inprogress_labels:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Prometheus FastAPI Instrumentator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>should_group_status_codes</code></strong> :&ensp;<code>bool</code></dt>
<dd>Should status codes be grouped into
<code>2xx</code>, <code>3xx</code> and so on? Defaults to <code>True</code>.</dd>
<dt><strong><code>should_ignore_untemplated</code></strong> :&ensp;<code>bool</code></dt>
<dd>Should requests without a matching
template be ignored? Defaults to <code>False</code>. This means that by
default a request like <code>curl -X GET localhost:80/doesnotexist</code>
will be ignored.</dd>
<dt><strong><code>should_group_untemplated</code></strong> :&ensp;<code>bool</code></dt>
<dd>Should requests without a matching
template be grouped to handler <code>none</code>? Defaults to <code>True</code>.</dd>
<dt><strong><code>should_round_latency_decimals</code></strong></dt>
<dd>Should recorded latencies be
rounded to a certain number of decimals?</dd>
<dt><strong><code>should_respect_env_var</code></strong> :&ensp;<code>bool</code></dt>
<dd>Should the instrumentator only work - for
example the methods <code>instrument()</code> and <code>expose()</code> - if a
certain environment variable is set to <code>true</code>? Usecase: A base
FastAPI app that is used by multiple distinct apps. The apps
only have to set the variable to be instrumented. Defaults to
<code>False</code>.</dd>
<dt><strong><code>should_instrument_requests_inprogress</code></strong> :&ensp;<code>bool</code></dt>
<dd>Enables a gauge that shows
the inprogress requests. See also the related args starting
with <code>inprogress</code>. Defaults to <code>False</code>.</dd>
<dt><strong><code>excluded_handlers</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of strings that will be compiled
to regex patterns. All matches will be skipped and not
instrumented. Defaults to <code>[]</code>.</dd>
<dt><strong><code>round_latency_decimals</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of decimals latencies should be
rounded to. Ignored unless <code>should_round_latency_decimals</code> is
<code>True</code>. Defaults to <code>4</code>.</dd>
<dt><strong><code>env_var_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Any valid os environment variable name that will
be checked for existence before instrumentation. Ignored unless
<code>should_respect_env_var</code> is <code>True</code>. Defaults to <code>"ENABLE_METRICS"</code>.</dd>
<dt><strong><code>inprogress_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the gauge. Defaults to
<code>http_requests_inprogress</code>. Ignored unless
<code>should_instrument_requests_inprogress</code> is <code>True</code>.</dd>
<dt><strong><code>inprogress_labels</code></strong> :&ensp;<code>bool</code></dt>
<dd>Should labels <code>method</code> and <code>handler</code> be
part of the inprogress label? Ignored unless
<code>should_instrument_requests_inprogress</code> is <code>True</code>. Defaults to <code>False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrometheusFastApiInstrumentator:
    def __init__(
        self,
        should_group_status_codes: bool = True,
        should_ignore_untemplated: bool = False,
        should_group_untemplated: bool = True,
        should_round_latency_decimals: bool = False,
        should_respect_env_var: bool = False,
        should_instrument_requests_inprogress: bool = False,
        excluded_handlers: List[str] = [],
        round_latency_decimals: int = 4,
        env_var_name: str = &#34;ENABLE_METRICS&#34;,
        inprogress_name: str = &#34;http_requests_inprogress&#34;,
        inprogress_labels: bool = False,
    ):
        &#34;&#34;&#34;Create a Prometheus FastAPI Instrumentator.

        Args:
            should_group_status_codes (bool): Should status codes be grouped into
                `2xx`, `3xx` and so on? Defaults to `True`.

            should_ignore_untemplated (bool): Should requests without a matching
                template be ignored? Defaults to `False`. This means that by
                default a request like `curl -X GET localhost:80/doesnotexist`
                will be ignored.

            should_group_untemplated (bool): Should requests without a matching
                template be grouped to handler `none`? Defaults to `True`.

            should_round_latency_decimals: Should recorded latencies be
                rounded to a certain number of decimals?

            should_respect_env_var (bool): Should the instrumentator only work - for
                example the methods `instrument()` and `expose()` - if a
                certain environment variable is set to `true`? Usecase: A base
                FastAPI app that is used by multiple distinct apps. The apps
                only have to set the variable to be instrumented. Defaults to
                `False`.

            should_instrument_requests_inprogress (bool): Enables a gauge that shows
                the inprogress requests. See also the related args starting
                with `inprogress`. Defaults to `False`.

            excluded_handlers (List[str]): List of strings that will be compiled
                to regex patterns. All matches will be skipped and not
                instrumented. Defaults to `[]`.

            round_latency_decimals (int): Number of decimals latencies should be
                rounded to. Ignored unless `should_round_latency_decimals` is
                `True`. Defaults to `4`.

            env_var_name (str): Any valid os environment variable name that will
                be checked for existence before instrumentation. Ignored unless
                `should_respect_env_var` is `True`. Defaults to `&#34;ENABLE_METRICS&#34;`.

            inprogress_name (str): Name of the gauge. Defaults to
                `http_requests_inprogress`. Ignored unless
                `should_instrument_requests_inprogress` is `True`.

            inprogress_labels (bool): Should labels `method` and `handler` be
                part of the inprogress label? Ignored unless
                `should_instrument_requests_inprogress` is `True`. Defaults to `False`.
        &#34;&#34;&#34;

        self.should_group_status_codes = should_group_status_codes
        self.should_ignore_untemplated = should_ignore_untemplated
        self.should_group_untemplated = should_group_untemplated
        self.should_round_latency_decimals = should_round_latency_decimals
        self.should_respect_env_var = should_respect_env_var
        self.should_instrument_requests_inprogress = should_instrument_requests_inprogress

        self.round_latency_decimals = round_latency_decimals
        self.env_var_name = env_var_name
        self.inprogress_name = inprogress_name
        self.inprogress_labels = inprogress_labels

        self.excluded_handlers: List[Pattern[str]]
        if excluded_handlers:
            self.excluded_handlers = [re.compile(path) for path in excluded_handlers]
        else:
            self.excluded_handlers = []

        self.instrumentations: List[Callable[[metrics.Info], None]] = []

    # ==========================================================================

    def instrument(self, app: FastAPI):
        &#34;&#34;&#34;Performs the instrumentation by adding middleware.

        The middleware iterates through all `instrumentations` and executes them.

        Args:
            app (FastAPI): FastAPI app instance.

        Raises:
            e: Only raised if FastAPI itself throws an exception.

        Returns:
            self: Instrumentator. Builder Pattern.
        &#34;&#34;&#34;

        if (
            self.should_respect_env_var
            and os.environ.get(self.env_var_name, &#34;false&#34;) != &#34;true&#34;
        ):
            return self

        if len(self.instrumentations) == 0:
            self.instrumentations.append(metrics.default())

        if self.should_instrument_requests_inprogress:
            labels = (
                (
                    &#34;method&#34;,
                    &#34;handler&#34;,
                )
                if self.inprogress_labels
                else ()
            )
            self.inprogress = Gauge(
                name=self.inprogress_name,
                documentation=&#34;Number of HTTP requests in progress.&#34;,
                labelnames=labels,
                multiprocess_mode=&#34;livesum&#34;,
            )

        # ----------------------------------------------------------------------

        @app.middleware(&#34;http&#34;)
        async def dispatch_middleware(request: Request, call_next) -&gt; Response:
            start_time = default_timer()

            handler, is_templated = self._get_handler(request)
            is_excluded = self._is_handler_excluded(handler, is_templated)
            handler = (
                &#34;none&#34; if not is_templated and self.should_group_untemplated else handler
            )

            if not is_excluded and self.should_instrument_requests_inprogress:
                inprogress: Gauge
                if self.inprogress_labels:
                    inprogress = self.inprogress.labels(request.method, handler)
                else:
                    inprogress = self.inprogress
                inprogress.inc()

            response = None
            status = &#34;500&#34;

            try:
                response = await call_next(request)
                status = str(response.status_code)
            except Exception as e:
                raise e from None
            finally:
                if not is_excluded:
                    duration = max(default_timer() - start_time, 0)

                    if self.should_instrument_requests_inprogress:
                        inprogress.dec()  # type: ignore

                    if self.should_round_latency_decimals:
                        duration = round(duration, self.round_latency_decimals)

                    if self.should_group_status_codes:
                        status = status[0] + &#34;xx&#34;

                    info = metrics.Info(
                        request=request,
                        response=response,
                        method=request.method,
                        modified_handler=handler,
                        modified_status=status,
                        modified_duration=duration,
                    )

                    for instrumentation in self.instrumentations:
                        instrumentation(info)

            return response

        # ----------------------------------------------------------------------

        return self

    # ==========================================================================

    def expose(
        self,
        app: FastAPI,
        should_gzip: bool = False,
        endpoint: str = &#34;/metrics&#34;,
        include_in_schema: bool = True,
        tags: Optional[List[str]] = None,
        **kwargs,
    ):
        &#34;&#34;&#34;Exposes endpoint for metrics.

        Args:
            app: FastAPI app instance. Endpoint will be added to this app.

            should_gzip: Should the endpoint return compressed data? It will
                also check for `gzip` in the `Accept-Encoding` header.
                Compression consumes more CPU cycles. In most cases it&#39;s best
                to just leave this option off since network bandwith is usually
                cheaper than CPU cycles. Defaults to `False`.

            endpoint: Endpoint on which metrics should be exposed.

            include_in_schema: Should the endpoint show up in the documentation?

            tags (List[str], optional): If you manage your routes with tags.
                Defaults to None.

            kwargs: Will be passed to FastAPI route annotation.

        Raises:
            ValueError: If `PROMETHEUS_MULTIPROC_DIR` env var is found but
                doesn&#39;t point to a valid directory.

        Returns:
            self: Instrumentator. Builder Pattern.
        &#34;&#34;&#34;

        if (
            self.should_respect_env_var
            and os.environ.get(self.env_var_name, &#34;false&#34;) != &#34;true&#34;
        ):
            return self

        from prometheus_client import (
            CONTENT_TYPE_LATEST,
            REGISTRY,
            CollectorRegistry,
            generate_latest,
            multiprocess,
        )

        if (
            &#34;prometheus_multiproc_dir&#34; in os.environ
            and &#34;PROMETHEUS_MULTIPROC_DIR&#34; not in os.environ
        ):
            os.environ[&#34;PROMETHEUS_MULTIPROC_DIR&#34;] = os.environ[
                &#34;prometheus_multiproc_dir&#34;
            ]
            warnings.warn(
                &#34;prometheus_multiproc_dir variable has been deprecated in favor of the \
upper case naming PROMETHEUS_MULTIPROC_DIR&#34;,
                DeprecationWarning,
            )
        if &#34;PROMETHEUS_MULTIPROC_DIR&#34; in os.environ:
            pmd = os.environ[&#34;PROMETHEUS_MULTIPROC_DIR&#34;]
            if os.path.isdir(pmd):
                registry = CollectorRegistry()
                multiprocess.MultiProcessCollector(registry)
            else:
                raise ValueError(
                    f&#34;Env var PROMETHEUS_MULTIPROC_DIR=&#39;{pmd}&#39; not a directory.&#34;
                )
        else:
            registry = REGISTRY

        @app.get(endpoint, include_in_schema=include_in_schema, tags=tags, **kwargs)
        def metrics(request: Request):
            &#34;&#34;&#34;Endpoint that serves Prometheus metrics.&#34;&#34;&#34;

            if should_gzip and &#34;gzip&#34; in request.headers.get(&#34;Accept-Encoding&#34;, &#34;&#34;):
                resp = Response(content=gzip.compress(generate_latest(registry)))
                resp.headers[&#34;Content-Type&#34;] = CONTENT_TYPE_LATEST
                resp.headers[&#34;Content-Encoding&#34;] = &#34;gzip&#34;
                return resp
            else:
                resp = Response(content=generate_latest(registry))
                resp.headers[&#34;Content-Type&#34;] = CONTENT_TYPE_LATEST
                return resp

        return self

    # ==========================================================================

    def add(self, instrumentation_function: Callable[[metrics.Info], None]):
        &#34;&#34;&#34;Adds function to list of instrumentations.

        Args:
            instrumentation_function (Callable[[metrics.Info], None]): Function
                that will be executed during every request handler call (if
                not excluded). See above for detailed information on the
                interface of the function.

        Returns:
            self: Instrumentator. Builder Pattern.
        &#34;&#34;&#34;

        self.instrumentations.append(instrumentation_function)

        return self

    # ==========================================================================

    def _get_handler(self, request: Request) -&gt; Tuple[str, bool]:
        &#34;&#34;&#34;Extracts either template or (if no template) path.

        Args:
            request (Request): Python Requests request object.

        Returns:
            Tuple[str, bool]: Tuple with two elements. First element is either
                template or if no template the path. Second element tells you
                if the path is templated or not.
        &#34;&#34;&#34;

        for route in request.app.routes:
            match, _ = route.matches(request.scope)
            if match == Match.FULL:
                return route.path, True

        return request.url.path, False

    # ==========================================================================

    def _is_handler_excluded(self, handler: str, is_templated: bool) -&gt; bool:
        &#34;&#34;&#34;Determines if the handler should be ignored.

        Args:
            handler (str): Handler that handles the request.
            is_templated (bool): Shows if the request is templated.

        Returns:
            bool: `True` if excluded, `False` if not.
        &#34;&#34;&#34;

        if is_templated is False and self.should_ignore_untemplated:
            return True

        if any(pattern.search(handler) for pattern in self.excluded_handlers):
            return True

        return False</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="prometheus_fastapi_instrumentator.instrumentation.PrometheusFastApiInstrumentator.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, instrumentation_function:Â Callable[[<a title="prometheus_fastapi_instrumentator.metrics.Info" href="metrics.html#prometheus_fastapi_instrumentator.metrics.Info">Info</a>],Â NoneType])</span>
</code></dt>
<dd>
<div class="desc"><p>Adds function to list of instrumentations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instrumentation_function</code></strong> :&ensp;<code>Callable[[metrics.Info], None]</code></dt>
<dd>Function
that will be executed during every request handler call (if
not excluded). See above for detailed information on the
interface of the function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self</code></dt>
<dd>Instrumentator. Builder Pattern.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, instrumentation_function: Callable[[metrics.Info], None]):
    &#34;&#34;&#34;Adds function to list of instrumentations.

    Args:
        instrumentation_function (Callable[[metrics.Info], None]): Function
            that will be executed during every request handler call (if
            not excluded). See above for detailed information on the
            interface of the function.

    Returns:
        self: Instrumentator. Builder Pattern.
    &#34;&#34;&#34;

    self.instrumentations.append(instrumentation_function)

    return self</code></pre>
</details>
</dd>
<dt id="prometheus_fastapi_instrumentator.instrumentation.PrometheusFastApiInstrumentator.expose"><code class="name flex">
<span>def <span class="ident">expose</span></span>(<span>self, app:Â fastapi.applications.FastAPI, should_gzip:Â boolÂ =Â False, endpoint:Â strÂ =Â '/metrics', include_in_schema:Â boolÂ =Â True, tags:Â Optional[List[str]]Â =Â None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Exposes endpoint for metrics.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>app</code></strong></dt>
<dd>FastAPI app instance. Endpoint will be added to this app.</dd>
<dt><strong><code>should_gzip</code></strong></dt>
<dd>Should the endpoint return compressed data? It will
also check for <code>gzip</code> in the <code>Accept-Encoding</code> header.
Compression consumes more CPU cycles. In most cases it's best
to just leave this option off since network bandwith is usually
cheaper than CPU cycles. Defaults to <code>False</code>.</dd>
<dt><strong><code>endpoint</code></strong></dt>
<dd>Endpoint on which metrics should be exposed.</dd>
<dt><strong><code>include_in_schema</code></strong></dt>
<dd>Should the endpoint show up in the documentation?</dd>
<dt><strong><code>tags</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>If you manage your routes with tags.
Defaults to None.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Will be passed to FastAPI route annotation.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>PROMETHEUS_MULTIPROC_DIR</code> env var is found but
doesn't point to a valid directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self</code></dt>
<dd>Instrumentator. Builder Pattern.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def expose(
        self,
        app: FastAPI,
        should_gzip: bool = False,
        endpoint: str = &#34;/metrics&#34;,
        include_in_schema: bool = True,
        tags: Optional[List[str]] = None,
        **kwargs,
    ):
        &#34;&#34;&#34;Exposes endpoint for metrics.

        Args:
            app: FastAPI app instance. Endpoint will be added to this app.

            should_gzip: Should the endpoint return compressed data? It will
                also check for `gzip` in the `Accept-Encoding` header.
                Compression consumes more CPU cycles. In most cases it&#39;s best
                to just leave this option off since network bandwith is usually
                cheaper than CPU cycles. Defaults to `False`.

            endpoint: Endpoint on which metrics should be exposed.

            include_in_schema: Should the endpoint show up in the documentation?

            tags (List[str], optional): If you manage your routes with tags.
                Defaults to None.

            kwargs: Will be passed to FastAPI route annotation.

        Raises:
            ValueError: If `PROMETHEUS_MULTIPROC_DIR` env var is found but
                doesn&#39;t point to a valid directory.

        Returns:
            self: Instrumentator. Builder Pattern.
        &#34;&#34;&#34;

        if (
            self.should_respect_env_var
            and os.environ.get(self.env_var_name, &#34;false&#34;) != &#34;true&#34;
        ):
            return self

        from prometheus_client import (
            CONTENT_TYPE_LATEST,
            REGISTRY,
            CollectorRegistry,
            generate_latest,
            multiprocess,
        )

        if (
            &#34;prometheus_multiproc_dir&#34; in os.environ
            and &#34;PROMETHEUS_MULTIPROC_DIR&#34; not in os.environ
        ):
            os.environ[&#34;PROMETHEUS_MULTIPROC_DIR&#34;] = os.environ[
                &#34;prometheus_multiproc_dir&#34;
            ]
            warnings.warn(
                &#34;prometheus_multiproc_dir variable has been deprecated in favor of the \
upper case naming PROMETHEUS_MULTIPROC_DIR&#34;,
                DeprecationWarning,
            )
        if &#34;PROMETHEUS_MULTIPROC_DIR&#34; in os.environ:
            pmd = os.environ[&#34;PROMETHEUS_MULTIPROC_DIR&#34;]
            if os.path.isdir(pmd):
                registry = CollectorRegistry()
                multiprocess.MultiProcessCollector(registry)
            else:
                raise ValueError(
                    f&#34;Env var PROMETHEUS_MULTIPROC_DIR=&#39;{pmd}&#39; not a directory.&#34;
                )
        else:
            registry = REGISTRY

        @app.get(endpoint, include_in_schema=include_in_schema, tags=tags, **kwargs)
        def metrics(request: Request):
            &#34;&#34;&#34;Endpoint that serves Prometheus metrics.&#34;&#34;&#34;

            if should_gzip and &#34;gzip&#34; in request.headers.get(&#34;Accept-Encoding&#34;, &#34;&#34;):
                resp = Response(content=gzip.compress(generate_latest(registry)))
                resp.headers[&#34;Content-Type&#34;] = CONTENT_TYPE_LATEST
                resp.headers[&#34;Content-Encoding&#34;] = &#34;gzip&#34;
                return resp
            else:
                resp = Response(content=generate_latest(registry))
                resp.headers[&#34;Content-Type&#34;] = CONTENT_TYPE_LATEST
                return resp

        return self</code></pre>
</details>
</dd>
<dt id="prometheus_fastapi_instrumentator.instrumentation.PrometheusFastApiInstrumentator.instrument"><code class="name flex">
<span>def <span class="ident">instrument</span></span>(<span>self, app:Â fastapi.applications.FastAPI)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs the instrumentation by adding middleware.</p>
<p>The middleware iterates through all <code>instrumentations</code> and executes them.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>FastAPI</code></dt>
<dd>FastAPI app instance.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>e</code></dt>
<dd>Only raised if FastAPI itself throws an exception.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self</code></dt>
<dd>Instrumentator. Builder Pattern.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def instrument(self, app: FastAPI):
    &#34;&#34;&#34;Performs the instrumentation by adding middleware.

    The middleware iterates through all `instrumentations` and executes them.

    Args:
        app (FastAPI): FastAPI app instance.

    Raises:
        e: Only raised if FastAPI itself throws an exception.

    Returns:
        self: Instrumentator. Builder Pattern.
    &#34;&#34;&#34;

    if (
        self.should_respect_env_var
        and os.environ.get(self.env_var_name, &#34;false&#34;) != &#34;true&#34;
    ):
        return self

    if len(self.instrumentations) == 0:
        self.instrumentations.append(metrics.default())

    if self.should_instrument_requests_inprogress:
        labels = (
            (
                &#34;method&#34;,
                &#34;handler&#34;,
            )
            if self.inprogress_labels
            else ()
        )
        self.inprogress = Gauge(
            name=self.inprogress_name,
            documentation=&#34;Number of HTTP requests in progress.&#34;,
            labelnames=labels,
            multiprocess_mode=&#34;livesum&#34;,
        )

    # ----------------------------------------------------------------------

    @app.middleware(&#34;http&#34;)
    async def dispatch_middleware(request: Request, call_next) -&gt; Response:
        start_time = default_timer()

        handler, is_templated = self._get_handler(request)
        is_excluded = self._is_handler_excluded(handler, is_templated)
        handler = (
            &#34;none&#34; if not is_templated and self.should_group_untemplated else handler
        )

        if not is_excluded and self.should_instrument_requests_inprogress:
            inprogress: Gauge
            if self.inprogress_labels:
                inprogress = self.inprogress.labels(request.method, handler)
            else:
                inprogress = self.inprogress
            inprogress.inc()

        response = None
        status = &#34;500&#34;

        try:
            response = await call_next(request)
            status = str(response.status_code)
        except Exception as e:
            raise e from None
        finally:
            if not is_excluded:
                duration = max(default_timer() - start_time, 0)

                if self.should_instrument_requests_inprogress:
                    inprogress.dec()  # type: ignore

                if self.should_round_latency_decimals:
                    duration = round(duration, self.round_latency_decimals)

                if self.should_group_status_codes:
                    status = status[0] + &#34;xx&#34;

                info = metrics.Info(
                    request=request,
                    response=response,
                    method=request.method,
                    modified_handler=handler,
                    modified_status=status,
                    modified_duration=duration,
                )

                for instrumentation in self.instrumentations:
                    instrumentation(info)

        return response

    # ----------------------------------------------------------------------

    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="prometheus_fastapi_instrumentator" href="index.html">prometheus_fastapi_instrumentator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="prometheus_fastapi_instrumentator.instrumentation.PrometheusFastApiInstrumentator" href="#prometheus_fastapi_instrumentator.instrumentation.PrometheusFastApiInstrumentator">PrometheusFastApiInstrumentator</a></code></h4>
<ul class="">
<li><code><a title="prometheus_fastapi_instrumentator.instrumentation.PrometheusFastApiInstrumentator.add" href="#prometheus_fastapi_instrumentator.instrumentation.PrometheusFastApiInstrumentator.add">add</a></code></li>
<li><code><a title="prometheus_fastapi_instrumentator.instrumentation.PrometheusFastApiInstrumentator.expose" href="#prometheus_fastapi_instrumentator.instrumentation.PrometheusFastApiInstrumentator.expose">expose</a></code></li>
<li><code><a title="prometheus_fastapi_instrumentator.instrumentation.PrometheusFastApiInstrumentator.instrument" href="#prometheus_fastapi_instrumentator.instrumentation.PrometheusFastApiInstrumentator.instrument">instrument</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>